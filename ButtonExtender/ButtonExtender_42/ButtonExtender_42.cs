using System;
using Microsoft.SPOT;

using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.Interfaces;
using System.Threading;

namespace Gadgeteer.Modules.SchreiberDominik
{
    /// <summary>
    /// A ButtonExtender module for Microsoft .NET Gadgeteer
    /// </summary>
    public class ButtonExtender : GTM.Module
    {
        private GTI.DigitalInput[] buttonArray = new GTI.DigitalInput[7];

        private bool isPressed;
        private byte pressedStates;
        private const int DefaultPollTimerInterval = 25;

        private Timer pollButtonsTimer;

        /// <summary>Gets or sets the interval how often the buttonstates are polled. Interval in ms.</summary>
        private int _pollTimerInterval;
        public int PollTimerInterval 
        {
            get
            {
                return _pollTimerInterval;
            }
            set
            {
                _pollTimerInterval = value;
                pollButtonsTimer.Interval = new TimeSpan(0, 0, 0, 0, value);
            }
        }
        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public ButtonExtender(int socketNumber)
        {
            Socket socket = Socket.GetSocket(socketNumber, true, this, null);
            socket.EnsureTypeIsSupported(new char[] { 'Y' }, this);

            buttonArray[0] = new GTI.DigitalInput(socket, Socket.Pin.Three, GTI.GlitchFilterMode.On, GTI.ResistorMode.PullUp, this);
            buttonArray[1] = new GTI.DigitalInput(socket, Socket.Pin.Four, GTI.GlitchFilterMode.On, GTI.ResistorMode.PullUp, this);
            buttonArray[2] = new GTI.DigitalInput(socket, Socket.Pin.Five, GTI.GlitchFilterMode.On, GTI.ResistorMode.PullUp, this);
            buttonArray[3] = new GTI.DigitalInput(socket, Socket.Pin.Six, GTI.GlitchFilterMode.On, GTI.ResistorMode.PullUp, this);
            buttonArray[4] = new GTI.DigitalInput(socket, Socket.Pin.Seven, GTI.GlitchFilterMode.On, GTI.ResistorMode.PullUp, this);
            buttonArray[5] = new GTI.DigitalInput(socket, Socket.Pin.Eight, GTI.GlitchFilterMode.On, GTI.ResistorMode.PullUp, this);
            buttonArray[6] = new GTI.DigitalInput(socket, Socket.Pin.Nine, GTI.GlitchFilterMode.On, GTI.ResistorMode.PullUp, this);           
            
            pollButtonsTimer = new Timer(DefaultPollTimerInterval, Timer.BehaviorType.RunContinuously);
            pollButtonsTimer.Tick += PollButtonsTimer_Tick;
            pollButtonsTimer.Start();
        }

        void PollButtonsTimer_Tick(Timer timer)
        {
            for (Int16 i = 0; i < buttonArray.Length; i++)
            {
                if (!buttonArray[i].Read() && (pressedStates & (byte)System.Math.Pow(2, i)) == 0)
                {
                    pressedStates |= ((byte)System.Math.Pow(2, i));
                    OnButtonEvent(i, ButtonState.Pressed);
                }
                else if (buttonArray[i].Read() && (pressedStates & (byte)System.Math.Pow(2, i)) != 0)
                {
                    pressedStates = (byte)(pressedStates & ~((byte)System.Math.Pow(2, i)));
                    OnButtonEvent(i, ButtonState.Released);
                }
            }
        }

        /// <summary>
        /// Gets a value that indicates whether the selected button of the ButtonExtender is pressed.
        /// </summary>
        public bool IsPressed(Int16 buttonNumber)
        {
            return !buttonArray[buttonNumber].Read();
        }
       
        /// <summary>
        /// Represents the state of button of the <see cref="ButtonExtender"/>.
        /// </summary>
        public enum ButtonState
        {
            /// <summary>
            /// The button is released.
            /// </summary>
            Released = 0,
            /// <summary>
            /// The button is pressed.
            /// </summary>
            Pressed = 1
        }

        /// <summary>
        /// Represents the delegate that is used to handle the <see cref="ButtonPressed"/>
        /// and <see cref="ButtonReleased"/> events.
        /// </summary>
        /// <param name="sender">The <see cref="ButtonExtender"/> object that raised the event.</param>
        /// <param name="state">The state of the button of the <see cref="ButtonExtender"/></param>
        public delegate void ButtonEventHandler(Int16 buttonNumber, ButtonState state);

        /// <summary>
        /// Raised when a button of the <see cref="ButtonExtender"/> is pressed.
        /// </summary>
        /// <remarks>
        /// Implement this event handler and/or the <see cref="ButtonReleased"/> event handler
        /// when you want to provide an action associated with button events.
        /// Since the state of the button is passed to the <see cref="ButtonEventHandler"/> delegate,
        /// you can use the same event handler for both button states.
        /// </remarks>
        public event ButtonEventHandler ButtonPressed;

        /// <summary>
        /// Raised when a button of the <see cref="ButtonExtender"/> is released.
        /// </summary>
        /// <remarks>
        /// Implement this event handler and/or the <see cref="ButtonPressed"/> event handler
        /// when you want to provide an action associated with button events.
        /// Since the state of the button is passed to the <see cref="ButtonEventHandler"/> delegate,
        /// you can use the same event handler for both button states.
        /// </remarks>
        public event ButtonEventHandler ButtonReleased;

        private ButtonEventHandler onButton;

        /// <summary>
        /// Raises the <see cref="ButtonPressed"/> or <see cref="ButtonReleased"/> event.
        /// </summary>
        /// <param name="sender">The <see cref="ButtonExtender"/> that raised the event.</param>
        /// <param name="buttonState">The state of the button.</param>
        protected virtual void OnButtonEvent(Int16 buttonNumber, ButtonState buttonState)
        {
            if (this.onButton == null)
                this.onButton = new ButtonEventHandler(this.OnButtonEvent);

            if (buttonState == ButtonState.Pressed)
            {
                // Program.CheckAndInvoke helps event callers get onto the Dispatcher thread.  
                // If the event is null then it returns false.
                // If it is called while not on the Dispatcher thread, it returns false but also re-invokes this method on the Dispatcher.
                // If on the thread, it returns true so that the caller can execute the event.
                if (Program.CheckAndInvoke(ButtonPressed, this.onButton, buttonNumber, buttonState))
                    this.ButtonPressed(buttonNumber, buttonState);
            }
            else
                if (Program.CheckAndInvoke(ButtonReleased, this.onButton, buttonNumber, buttonState))
                    this.ButtonReleased(buttonNumber, buttonState);
        }
    }
}
